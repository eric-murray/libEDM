#pragma once

#define _USE_MATH_DEFINES
#include <cmath>
#include <vector>

#include <boost/dynamic_bitset.hpp>

#include <libEDM_matrix.h>

using std::pair;
using std::vector;

using boost::dynamic_bitset;

class Codec {
public:
    enum Metric {LOGMAP, LOGMAX, MAP, SOVA};
};

class ConvolutionalCodec : public Codec {
public:

    ConvolutionalCodec(const size_t constraintLength, const uVector &parityGenerators, const size_t feedbackGenerator, const bool terminated, const bool systematic, const size_t decoderDelay = 0);

    void set_awgn_channel_parameters(const double channelSNR) {set_scaling_factor(4.0 * channelSNR);}
    void set_scaling_factor         (const double Lc)         {this->Lc = Lc;}

    bVector encode(const bVector &input, bVector &tail, bMatrix &parityBits) const;

    // decodes a block of received data and returns the soft decisions (LLR)
    dVector decode(const dVector &input, const dVector &extrinsicInput, const Metric metric);

    // decodes a block of received data and returns the hard decisions
	bVector decode(const dVector &input, const Metric metric);

private:

	// a state of the Viterbi decoder
	class State
	{
    private:
		// a transition into the state - each state has two transitions into it
		class Transition
		{
		public:
		    const bool         inputBit;					// the value of the source bit required to trigger the transition
			      State *const state;						// a pointer to the state to which the transition goes

			// constructors
			Transition(State *const state, const size_t previousStateIndex, const bool inputBit)
                : state              (state),
                  inputBit           (inputBit),
                  _previousStateIndex(previousStateIndex),
                  _outputBits        (state->codec->outputParity[previousStateIndex][inputBit].to_ulong()) {}

			// returns the cumulative metrics associated with the transition
			double cumulativeMetric()     {return previousState()->cumulativeMetric()     + incrementalMetric();}
			double cumulativeSOVAMetric() {return previousState()->cumulativeSOVAMetric() + incrementalSOVAMetric();}
			size_t cumulativeDistance()   {return previousState()->cumulativeDistance()   + incrementalDistance();}

			// returns the incremental metrics associated with the transition, which is stored in a LUT
			double incrementalMetric()     {return state->codec->incrementalMetricsTable    [_outputBits];}
			double incrementalSOVAMetric() {return state->codec->incrementalSOVAMetricsTable[_outputBits];}
			size_t incrementalDistance()   {return state->codec->incrementalDistanceTable   [_outputBits];}

			// returns a pointer to the state from which the transition originated
			// this cannot be initialised by the constructer because state may not have been instantiated
			State *previousState() {return (*state->previousStates)[_previousStateIndex];}

		private:
			const size_t _outputBits;				// the output bits generated by the transition
			const size_t _previousStateIndex;		// the index of the state from which the transition comes
		};

    public:
		const size_t index;											// the state index, as represented by the shift register

        ConvolutionalCodec  *const codec;							// pointer to the codec object
		vector<State*>      *const previousStates;					// pointer to the vector of previous states (odd or even)
		bVector                    sequenceEstimate;				// the current sequence estimate
		dVector                    sequenceProbError;				// store for current estimates of bit error probabilities 
		Transition                 transitionA, transitionB;		// the two possible transitions into the state

		// constructors
		State(const size_t index, ConvolutionalCodec *const codec, vector<State*> *const previousStates)
            : index(index),
              codec(codec),
              previousStates(previousStates),
              transitionA(this, codec->reverseStateTransition[index][0].first, codec->reverseStateTransition[index][0].second),
              transitionB(this, codec->reverseStateTransition[index][1].first, codec->reverseStateTransition[index][1].second)
              {}

		size_t cumulativeDistance()   {return _cumulativeDistance;}
		double cumulativeMetric()     {return _cumulativeMetric;}
		double cumulativeSOVAMetric() {return _cumulativeSOVAMetric;}

		// updates a transition following the transmission of a source bit and return likelihood ratio if decision required
		double process_transitions(const size_t sourceBitIndex);

		// resets the state at the start of a block
		void reset(const size_t maxSize);

		// updates the state after process_transitions has been called for all states
		void update();

	private:
		double  _cumulativeMetric;								// store for cumulative metric
		double  _cumulativeSOVAMetric;            				// store for cumulative SOVA metric
		size_t  _cumulativeDistance;                            // store for cumulative distance metric
	};

    const size_t  m;                    // number of shift register elemenrs in constituent coder
    const size_t  n;                    // number of constituent coders
    const size_t  numStates;            // number of coder states = 2^n
    const bool    terminated;           // is code terminated
    const bool    systematic;           // is code systematic
    const size_t  decoderDelay;         // traceback delay if Viterbi decoder is used

    dynamic_bitset<>          feedbackGenerator;
    vector<dynamic_bitset<> > parityGenerators;

    double Lc;

    uMatrix                              stateTransition;
    vector<vector<pair<size_t, bool> > > reverseStateTransition;
    Matrix<dynamic_bitset<> >            outputParity;

    // storage for Viterbi metrics
    dVector        incrementalMetricsTable, incrementalSOVAMetricsTable;		// global incremental metrics tables
	uVector        incrementalDistanceTable;
   	vector<State*> oddStates, evenStates;										// the states of the Viterbi decoder

    size_t constraintLength() const {return m+1;}                               // constraint length

    size_t calc_state_transition (const size_t inputState, const bool inputBit, dynamic_bitset<> &parityBits) const;
    void          unsplice              (const dVector &input, dVector &rxSystematic, dMatrix &rxParity) const;

    dVector decode_MAP (const dVector &input, const dVector &extrinsicInput);
    dVector decode_LOG (const dVector &input, const dVector &extrinsicInput, const Metric);
   	dVector decode_SOVA(const dVector &input, const dVector &snr_estimates);

	// computes the incremental metrics table following the reception of the bits corresponding to a transition
	void compute_incremental_metrics_table(dVector::const_iterator received_transition_bits, dVector::const_iterator snr_estimates);

	// resets the codec at the start of each block
	void reset(const size_t maxSize);
};